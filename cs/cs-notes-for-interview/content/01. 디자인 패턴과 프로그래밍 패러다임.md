# SECTION 1. 디자인 패턴
`프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것`

## 1.1 싱글톤 패턴
`하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴`
- 데이터베이스 연결 모듈에 많이 사용
- 하나의 인스턴스를 만들어놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스 생성 비용이 절약됨 (+)
- 의존성이 높아짐 (-)
### 자바에서의 싱글톤 패턴
- 중첩 클래스를 이용해 만드는 것이 가장 대중적인 방법
```java
class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return singleInstanceHolder.INSTANCE;
    }
}
```
### 싱글톤 패턴의 단점
- 단위 테스트의 경우 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행 가능해야 하지만, 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어렵

### 의존성 주입
`메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식`
- 의존성 주입을 통해 모듈 간의 결합을 느슨히 하고, 싱글톤 패턴의 단점을 해결 가능
- 의존성 주입의 장점 (+)
  - 모듈을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기도 수월해짐
  - 애플리케이션 의존성 방향이 일관되어짐
- 의존성 주입의 단점 (-)
  - 복잡성 증가 및 런타임 페널티

## 1.2 팩토리 패턴
`객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴`
- 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 많은 유연성을 가짐
- 객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩토링하더라도 한 곳만 고칠 수 있게 되고, 유지 보수성이 증가됨
### 자바의 팩토리 패턴
```java
enum CoffeeType {
    LATTE,
    ESPRESSO
}

abstract class Coffee {
    protected String name;
    
    public String getName() {
        return name;
    }
}

class Latte extends Coffee {
    public Latte() {
        name = "latte";
    }
}

class Espresso extends Coffee {
    public Espresso() {
        name = "Espresso";
    }
}

class CoffeeFactory {
    public static Coffee createCoffee(CoffeeType type) {
        switch (type) {
            case LATTE:
                return new Latte();
            case ESPRESSO:
                return new Espresso();
            default:
                throw new IllegalArgumentException("Invalid coffee type: " + type);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Coffee coffee = CoffeeFactory.createCoffee(CoffeeType.LATTE);
    }
}
```

## 1.3 전략 패턴
`정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주며 상호 교체가 가능하게 만드는 패턴`
- 결제 방식의 '전략'을 카카오페이와 네이버페이 두 가지로 구현한 것도 하나의 예시

## 1.4 옵저버 패턴
`주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴`
- 주체 : 객체의 상태 변화를 보고 있는 관찰자
- 옵저버 : 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변화 사항이 생기는 객체들
- 주로 이벤트 기반 시스템에 사용하며 프록시 객체를 사용해 구현되고는 한다.

## 1.5 프록시 패턴과 프록시 서버
`대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴`
- 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
### 프록시 서버
`서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램`
- 프록시 서버로서의 nginx
  - 익명 사용자가 직접적으로 서버에 접근하는 것 차단
  - 실제 포트를 숨길 수 있고, 정적 자원을 gzip 압축하거나 메인 서버 앞단에서의 로깅을 할 수 있음
- 프록시 서버로서의 CloudFlare
  - CDN 서비스
  - DDOS 공격 방어나 HTTPS 구축에 사용
- CORS와 프론트엔드의 프록시 서버
  - 프론트엔드 서버 앞단에 프록시 서버를 놓아 요청의 오리진을 백엔드 서버와 통일시켜줌

## 1.6 이터레이터 패턴
`이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴`
- 이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
- 이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체

## 1.7 노출모듈 패턴
`즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴`
- 자바 스크립트의 경우 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행됨 -> 노출모듈 패턴을 통해 접근 제어자 구현 가능

## 1.8 MVC 패턴
`모델, 뷰, 컨트롤러로 이루어진 디자인 패턴`
- 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발 가능
- 재사용성과 확장성 용이 (+)
- 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐
### 모델
`애플리케이션의 데이터인 데이터베이스, 상수, 변수`
### 뷰
`사용자 인터페이스 요소. 모델을 기반으로 사용자가 볼 수 있는 화면`
### 컨트롤러
`하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직 담당. 모델과 뷰의 생명주기도 관리`

## 1.9 MVP 패턴
`MVC에서 C에 해당하는 컨트롤러가 프레젠터로 교체된 패턴`
- 뷰와 프레젠터는 일대일 관계로, MVC 패턴보다 더 강한 결합을 가지게 됨

## 1.10 MVVM 패턴
`MVC의 C에 해당하는 컨트롤러가 뷰 모델 (View Model)로 바뀐 패턴`
- 뷰 모델은 뷰를 더 추상화한 계층으로, MVC 패턴과 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징
- 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점 존재

---
# Section 2. 프로그래밍 패러다임

`프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론`
- 프로그래밍 패러다임은 크게 선언형, 명령형으로 나뉜다.
  - 선언형은 함수형이라는 하위 집합을 갖는다.
  - 명령형은 다시 객체지향과 절차지향으로 나뉜다.

## 2.1 선언형과 함수형 프로그래밍
- 선언형 프로그래밍은 '무엇을' 풀어내는가에 집중하며. "프로그램은 함수로 이루어진 것이다." 라는 명제가 담겨있는 패러다임
- 함수형 프로그래밍은 '순수 함수'들을 블록처럼 쌓아 로직을 구현하고, '고차 함수'를 통해 재사용성을 높인 프로그래밍 패러다임

### 순수 함수
`동일한 입력에 대해 항상 동일한 출력을 반환하며, 외부 상태를 변경하지 않는 함수`

### 고차 함수
`함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것`
- 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 한다.
  - 변수나 메서드에 함수를 할당할 수 있음
  - 함수 안에 함수를 매개변수로 담을 수 있음
  - 함수가 함수를 반환할 수 있음

## 2.2 객체지향 프로그래밍
`객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식`

### 객체지향 프로그래밍의 특징
- **추상화** 
  - 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
  - 불필요한 세부사항 제거 & 본질적이고 공통적인 부분을 추출해 표현
  - Ex. `Car` 와 `MotorBike` 의 공통적인 기능을 추출하여 `Vehicle` 인터페이스에 정의 → 역할과 구현을 분리
- **캡슐화**
  - 서로 연관 있는 속성과 메서드를 묶어 클래스 안에 하나의 캡슐로 만들고 데이터를 외부로부터 감추어 은닉하는 것
  - 데이터 보호 → 외부로부터 클래스에 정의된 속성과 기능들을 보호
  - 데이터 은닉 → 내부의 동작을 감추고 외부에는 필요한 부분만 노출
- **상속성**
  - 상위 클래스의 특성을 하위 클래스가 이어받아 재사용하거나 추가, 확장하는 것
  - 코드의 재사용성, 계층적인 관계 생성, 유지 보수성 측면에서 중요
- **다형성**
  - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
  - Ex. `오버로딩`과 `오버라이딩`
    - 오버로딩
      - 매개변수의 타입 또는 개수가 다르고, 같은 이름을 가진 메서드를 여러 개 두는 것
      - 컴파일 중에 발생하는 정적 다형성
    - 오버라이딩
      - 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
      - 런타임 중에 발생하는 동적 다형성

### 설계 원칙 (SOLID)
- **SRP** (Single Responsibility)
  - 모든 클래스는 각각 하나의 책임만 가져야 한다.
  - 프로그램의 유지보수성을 높이기 위한 설계 기법
- **OCP** (Open Closed)
  - 확장에 열려있어야 하며, 수정에 닫혀있어야 한다.
  - 새로운 변경사항이 생겼을 때 기존의 코드를 변경하지 않으면서 유연하게 확장할 수 있어야 한다는 의미
- **LSP** (Liskov Substitution)
  - 상위 타입의 객체를 하위 타입의 객체로 대체하여도 정상적으로 작동해야 한다.
  - Ex. 상위 클래스 타입으로 객체 선언 후 하위 클래스의 인스턴스를 받아도 정상 작동 (업캐스팅)
  - 다형성을 지원하기 위한 설계 기법
- **ISP** (Interface Segregation)
  - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 한다.
  - 인터페이스의 단일 책임 강조
- **DIP** (Dependency Injection)
  - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존해야 한다.
  - 구현 클래스에 의존하지 말고 상위 요소(추상 클래스나 인터페이스)에 의존하라는 의미
  - 각 클래스 간의 결합도를 낮추기 위한 설계 기법

## 2.3 절차형 프로그래밍
- 코드의 가독성이 좋으며 실행 속도가 빠르다. (+)
- 모듈화하기 어렵고 유지보수성이 떨어진다. (-)
- 대표적으로 포트란을 이용한 대기 과학 관련 연산 작업, 머신 러닝의 배치 작업 등이 존재

