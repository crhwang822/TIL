# 1장. 사용자 수에 따른 규모 확장성

## 단일 서버
웹, 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행되는 구조

## 데이터베이스
사용자가 늘어남 → 용도에 따라 서버 분리
- 웹/모바일 트래픽 처리 서버 (웹 계층)
- 데이터베이스 서버 (데이터 계층)

### 어떤 데이터베이스를 사용할 것인가?
- 비관계형 데이터베이스가 바람직한 경우
    - 아주 낮은 응답 지연시간 (latency) 요구
    - 비정형 데이터를 다룸
    - 데이터를 직렬화하거나 역직렬화할 수 있기만 하면 됨
    - 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 VS 수평적 규모 확장
- `수직적 규모 확장 (scale up)` : 서버에 고사양 자원을 추가하는 행위
    - 서버로 유입되는 트래픽 양이 적을 때 좋은 선택 (+)
    - but 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법 X. 한계 존재 (-)
    - 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시 X
- `수평적 규모 확장 (scale out)` : 더 많은 서버를 추가하여 성능을 개선하는 행위
    - 대규모 애플리케이션을 지원할 때 적절

> `failover` : 컴퓨터 서버, 시스템, 네트워크 등에서 문제가 발생했을 때 예비 시스템으로 자동 전환되어 서비스를 지속하는 기능

### 로드밸런서
부하 분산 집합 (load balancing set) 에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할   
앞선 설계에서 웹 서버가 다운되거나 트래픽이 몰리는 문제상황에 대한 해결책
- 로드밸런서의 동작 과정
    1. 사용자는 로드밸런서의 공개 IP 주소로 접속 → 웹 서버는 클라이언트의 접속을 직접 처리 X
    2. 로드밸런서는 서버 간 통신에 사용되는 사설 IP 주소를 이용하여 웹 서버와 통신 / 트래픽 분산
       3-1. 서버1이 다운되는 경우 모든 트래픽은 서버2로 전송 → no failover 문제 해소
       3-2. 웹사이트로 유입되는 트래픽이 가파르게 증가할 경우 웹 서버 계층 (부하 분산 집합)에 더 많은 서버를 추가하기만 하면 됨 → 웹 계층의 가용성 향상

### 데이터베이스 다중화
데이터를 여러 곳에 복제하거나 분산시키는 기술   
보통은 서버 사이에 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식을 사용
- 주 서버
    - 쓰기 연산은 주 서버에서만 지원
    - 데이터베이스를 변경하는 명령어는 주 서버로만 전달
    - 주 서버가 다운될 경우 부 서버 중 하나가 새로운 주 서버가 될 것이며, 모든 데이터베이스 연산은 일시적으로 새로운 주 서버상에서 수행
- 부 서버
    - 주 데이터베이스로부터 사본을 전달받으며, 읽기 연산 지원
    - 대부분의 애플리케이션은 읽기 연산의 비중이 높기 때문에 통상적으로 주 서버보다 그 수가 더 많음
    - 부 서버가 다운될 경우 읽기 연산은 나머지 부 서버들로 분산, 부 서버가 한 대 뿐이라면 읽기 연산이 한시적으로 주 서버로 전달됨
- 데이터베이스 다중화의 이점
    - 더 나은 성능 : 읽기 연산이 부 서버로 분산되기 때문에 병렬로 처리되는 쿼리 수가 늘어남
    - 안정성 : 데이터베이스 서버 가운데 일부가 파괴되어도 데이터베이스 보존 가능
    - 가용성 : 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 데이터베이스 서버를 통해 지속적으로 서비스 가능

## 캐시
값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소   
애플리케이션의 성능은 데이터베이스 호출 빈도에 크게 좌우되며, 캐시는 해당 문제를 완화할 수 있는 방안 중 하나

### 캐시 계층 (Cache tier)
별도의 캐시 계층을 둘 경우 성능 개선 뿐만 아니라 데이터베이스의 부하를 줄이고 캐시 계층의 규모를 독립적으로 확장하는 것도 가능
- 캐시 서버 이용 시나리오 (주도형 캐시 전략)
    1. 웹 서버는 요청을 받은 후 캐시에 응답이 저장되어있는지 확인
       2-1. 저장되어 있는 경우 해당 데이터를 클라이언트에 반환
       2-2. 없는 경우 데이터베이스에서 해당 데이터를 조회 후 캐시에 저장한 뒤 클라이언트에 반환
- 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 적절히 선택해야 함

### 캐시 사용 시 유의할 점
- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번히 일어나는 경우 사용하는 것이 바람직
- 캐시 서버는 재시작되면 모든 데이터가 사라지므로 영속적으로 보관할 데이터는 지속적 저장소에 저장되어야 함
- 만료 정책을 어떻게 설정할 것인가? 너무 짧을 경우 데이터베이스 조회 빈도가 올라가고, 너무 길 경우 일관성이 깨질 가능성이 올라감
- 저장소의 원본 갱신 연산과 캐시 갱신 연산은 하나의 트랜잭션으로 묶어야 일관성이 깨지지 않음. 여러 지역에 걸쳐 시스템을 확장해나가는 경우 일관성 유지의 난이도도 올라감
- 캐시 서버를 한 대만 두는 경우 해당 서버가 단일 장애 지점(SPOF)가 될 가능성이 존재. → 여러 지역에 걸쳐 캐시 서버를 분산시켜야 함
    - `SPOF (Single Point of Failure)` : 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우 해당 지점을 SPOF라고 한다.
- 캐시 메모리의 크기는 어떻게 설정할 것인가? 너무 작으면 데이터가 캐시에서 자주 밀려나 성능이 떨어짐 → 캐시 메모리를 과할당하면 막을 수 있음
- 캐시 데이터 방출 정책을 어떻게 설정할 것인가? LRU, LFU, FIFO 등 여러 정책 중 하나를 적절히 선택해야 함

## 콘텐츠 전송 네트워크 (CDN)
`CDN`은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크   
이미지, 비디오, CSS, JavaScript 등 정적 콘텐츠 캐시 가능   
특정 사용자가 웹사이트를 방문 시 해당 사용자로부터 가장 가까운 CDN 서버에서 정적 콘텐츠 제공
- CDN의 동작 과정
    1. 사용자 A가 URL을 이용해 `image.png` 에 접근. URL의 도메인은 CDN 서비스 사업자가 제공한 것
    2. CDN 서버의 캐시에 해당 이미지가 없는 경우 서버는 원본 서버에 요청해 파일을 가져옴
    3. 원본 서버가 파일을 CDN 서버에 반환. 응답의 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지를 나타내는 TTL 값이 포함됨
    4. CDN 서버는 파일을 캐시 후 사용자 A에게 반환
    5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송
    6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리

### CDN 사용 시 고려해야 할 사항
- 비용 : CDN은 보통 제3 사업자에 의해 운영되며, 데이터 전송량에 따른 요금을 지불하게 됨 → 자주 사용되지 않는 데이터를 캐싱하는 것은 가성비 떨어짐
- 만료 시한 설정 : 만료 시한이 너무 길 경우 콘텐츠의 신선도가 떨어지고, 너무 짧으면 원본 서버에 빈번히 접속하게 됨
- CDN 장애 대처 방안 : 일시적으로 CDN이 응답하지 않을 경우 해당 문제를 감지하여 원본 서버로부터 직접 컨텐츠를 가져오도록 클라이언트를 구성해야 함
- 콘텐츠 무효화 : 만료되지 않은 콘텐츠라 하더라도 서비스 사업자에서 제공하는 API나 콘텐츠의 다른 버전을 서비스하도록 하는 오브젝트 버저닝을 이용해 콘텐츠를 CDN에서 제거 가능

## 무상태(stateless) 웹 계층
웹 계층을 수평적으로 확장하기 위해서는 상태 정보 (ex. 세션 데이터) 를 웹 계층에서 제거해야 한다   
이를 위해서는 상태 정보를 지속적 저장소에 보관하고, 필요할 때 가져와야 함

### 상태 정보 의존적인 아키텍처
상태 정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 함   
→ 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 하는 문제 발생   
→ 대부분의 로드밸런서는 이를 지원하기 위해 고정 세션이라는 기능을 제공하는데, 이는 로드밸런서에 부담을 주며 장애 처리가 복잡해지는 등 단점 존재

### 무상태 아키텍처
사용자로부터의 요청이 어떤 서버로든 전달 가능함   
→ 웹 서버가 상태 정보가 필요할 경우 공유 저장소로부터 가져오면 됨    
→ 구조가 단순, 안정적이며 규모 확장이 쉬워짐
- `오토 스케일링 (autoscaling)` : 트래픽 양에 따라 웹 서버를 자동으로 추가하거나 삭제하는 기능

## 데이터 센터
- `지리적 라우팅 (geoDNS-routing)` : 여러 개의 데이터 센터를 이용할 때, 장애가 없는 상황에서 사용자가 가장 가까운 데이터 센터로 안내되는 절차
- `GeoDNS` : 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스

### 다중 데이터센터 아키텍처의 기술적 난제
- 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야함. Ex. GeoDNS
- 데이터 동기화 : 데이터 센터마다 별도의 데이터베이스를 사용하는 경우, 장애가 자동으로 복구되어 트래픽은 우회된다고 하더라도 데이터 동기화 문제 발생 가능. 보편적인 해결 전략은 데이터를 여러 데이터 센터에 걸쳐 다중화하는 것이다. (Netflix)
- 테스트와 배포 : 여러 데이터센터를 사용할 경우 애플리케이션을 여러 위치에서 테스트해보는 것이 중요.

## 메시지 큐
- `메시지 큐` : 메시지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트
- 메시지의 `무손실` (durability) : 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성
- 메시지 큐의 기본 아키텍처
    1. 생산자(producer) / 발행자(publisher) 라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publisih)
    2. 큐에는 보통 소비자(consumer) / 구독자(subscriber) 라 불리는 서비스 혹은 서버가 연결되어 있으며, 메시지를 받아 그에 맞는 동작을 수행함
- 메시지 큐의 장점
    - 서비스 또는 서버 간 결합이 느슨해져 규모 확장성이 보장되는 애플리케이션을 구성하기 쉬움
    - 생산자는 소비자 프로세스가 다운되어 있어도 메시지 발행이 가능하며, 소비자는 생산자 서비스가 가용한 상태가 아니어도 메시지 수신 가능
- 사용 예시
    - 사진 보정 애플리케이션 : 시간이 오래 걸릴 수 있는 이미지의 크로핑/샤프닝 등의 프로세스를 비동기적으로 처리할 때 이용

## 로그, 메트릭 그리고 자동화
- `로그` : 에러 로그 모니터링은 중요함. 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리
- `메트릭` : 메트릭을 잘 수집할 시 사업 현황에 관한 유용한 정보나 시스템의 현재 상태를 쉽게 파악 가능
    - 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O에 관한 메트릭이 여기 해당
    - 종합 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능 등이 해당
    - 핵심 비즈니스 메트릭 : 일별 능동 사용자(DAU), 수익, 재방문 등이 해당
- `자동화` : 생산성을 높여주는 CI 도구 등이 해당. 빌드, 테스트, 배포 등 절차를 자동화시켜 생산성을 크게 향상 가능

## 데이터베이스의 규모 확장
저장할 데이터가 많아질 시 데이터베이스에 대한 부하도 증가 → 데이터베이스 증설 필요

### 수직적 확장
- 데이터베이스 서버 하드웨어에는 한계가 존재하므로 사용자가 계속 늘어날 시 결국 한 대의 서버로는 감당이 어려울 것
- SPOF 위험성
- 고성능 서버로 갈수록 비용 부담 증가

### 수평적 확장 (Sharding)
- `샤딩` : 데이터베이스를 `샤드` 라고 부르는 작은 단위로 분할하는 기술. 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복 X
- 샤드로 분할된 데이터베이스 예시
    - 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 결정 → user_id % 4 를 해시함수로 사용
- 샤딩 전략 구현 시 가장 중요한 고려사항은 `샤딩 키`를 정하는 것
>  `샤딩 키` : 파티션 키라고도 불리우며, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성

### 샤딩 도입 시 고려해야할 문제사항
- 데이터 재샤딩 (resharding) : (1) 데이터가 너무 많아져서 하나의 샤드로 더이상 감당이 어려울 때 (2) 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때, 샤드 소진이라고도 부르는 현상이 발생하면 데이터 재배치 필요
- 유명인사 문제 : hotspot key 문제라고도 하며, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제를 말함
- 조인과 비정규화 : 여러 샤드에 걸친 데이터를 조인하기 힘들어짐 → 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행되도록 함

## 정리
시스템 규모 확장을 위한 기법을 다음과 같이 정리
1. 웹 계층은 무상태 계층으로
2. 모든 계층에 다중화 도입 (웹 서버, 캐시 서버, 데이터베이스, ...)
3. 가능한 한 많은 데이터를 캐시
4. 여러 데이터 센터를 지원
5. 정적 콘텐츠는 CDN을 통해 서비스
6. 데이터 계층은 샤딩을 통해 그 규모를 확장
7. 각 계층은 독립적 서비스로 분할
8. 시스템을 지속적으로 모니터링하고, 자동화 도구를 활용
